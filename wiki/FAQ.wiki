#labels faq
= Frequently asked questions =

  # PowerMockRunner throws a 
{{{
java.lang.NoClassDefFoundError: org/junit/internal/runners/BeforeAndAfterRunner
}}} 
  or 
{{{
java.lang.SecurityException: class "org.junit.internal.runners.TestClass"'s signer information does not match signer information of other classes in the same package
}}}
  exception. What's wrong?
   You're probably using the wrong PowerMockRunner. There's one runner made for JUnit 4.4 and above and a second runner made for JUnit 4.0-4.3 (although the latter also works for some older minor versions of JUnit 4.4). Try switching from the `org.powermock.modules.junit4.PowerMockRunner` to `org.powermock.modules.junit4.legacy.PowerMockRunner` or vice versa. Look at the [GettingStarted getting started] guide to see how to configure this in maven.
  # Cobertura gives me errors or produces strange results when running PowerMock tests in Maven, how do I solve this?
    You need to add the following to your pom.xml file:
{{{ 
 <build>
  <plugins>
     <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <configuration>
            <forkMode>pertest</forkMode> 
        </configuration>
      </plugin>
     </plugins>
  </build>
}}}
  # I cannot mock classes in from `java.lang`, `java.net`, `java.io` or other system classes, why?
    This is because they're loaded by Java's bootstrap classloader and cannot be byte-code manipulated by PowerMock's classloader. Since PowerMock 1.2.5 there's a work-around, please have a look at [http://code.google.com/p/powermock/source/browse/trunk/modules/module-test/powermock/junit4-test/src/test/java/samples/junit4/system/SystemClassUserTest.java this] simple example to see how it's done.
  # When mocking Hibernate you get an error similar to:
{{{
java.lang.ClassCastException: org.hibernate.ejb.HibernatePersistence cannot be cast to javax.persistence.spi.PersistenceProvider
    at javax.persistence.Persistence.findAllProviders(Persistence.java:80)
    at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:49)
    at javax.persistence.Persistence.createEntityManagerFactory(Persistence.java:34)
    ...
}}}
    Solution: Use `@PowerMockIgnore("javax.persistence")` at the class-level of your test.
  # When running a PowerMock test log4j gives me the following (or something similar) error, what now? 
{{{
log4j:ERROR A "org.apache.log4j.xml.DOMConfigurator" object is not
assignable to a "org.apache.log4j.spi.Configurator" variable.
log4j:ERROR The class "org.apache.log4j.spi.Configurator" was loaded
by
log4j:ERROR [org.powermock.core.classloader.MockClassLoader@14a55f2]
whereas object of type
log4j:ERROR "org.apache.log4j.xml.DOMConfigurator" was loaded by
[sun.misc.Launcher$AppClassLoader@92e78c].
log4j:ERROR Could not instantiate configurator
[org.apache.log4j.xml.DOMConfigurator].
}}}
      There are a couple of different solutions to this:
        # Make use of the @PowerMockIgnore annotation, for example if using log4j use @PowerMockIgnore("org.apache.log4j") at the class-level of the test.
        # If you're using PowerMock 1.1 or above you should use the `@MockPolicy` annotation and specify a mock policy. For example if you're using slf4j in combination with log4j use `@MockPolicy(Slf4jMockPolicy.class)` or if you're using Log4j stand-alone use `@MockPolicy(Log4jMockPolicy.class)`. This is the recommended way. For example:
{{{
@RunWith(PowerMockRunner.class)
@MockPolicy(Log4jMockPolicy.class)
public class MyTest {

}
}}}
        # Create a nice mock of the Logger class and set the the Logger field to this instance. If the field is static suppress the static initializer for the class (using the `@SuppressStaticInitializerFor` annotation) and then set the logger field to the mock you just created. Next prepare the `org.apache.log4j.Appender` for testing using the @PrepareForTest annotation. For example:
{{{
@RunWith(PowerMockRunner.class)
@SuppressStaticInitializationFor("org.myapp.MyClassUsingLog4J")
@PrepareForTest( { Appender.class })
public class MyTest {

  @Before
  public void setUp() {
      Logger loggerMock = createNiceMock(Logger.class);
      Whitebox.setInternalState(MyClassUsingLog4J.class, loggerMock);
      ...
  }
  ...
}
}}}
        # Follow the same procedure as in the previous step but instead of adding the `org.apache.log4j.Appender` class to the `@PrepareForTest` annotation you add `"org.apache.log4j.LogManager"` to the `@SuppressStaticInitializerFor` annotation. For example:
{{{
@RunWith(PowerMockRunner.class)
@SuppressStaticInitializationFor( {
		"org.myapp.MyClassUsingLog4J",
		"org.apache.log4j.LogManager" })
public class MyTest {

  @Before
  public void setUp() {
      Logger loggerMock = createNiceMock(Logger.class);
      Whitebox.setInternalState(MyClassUsingLog4J.class, loggerMock);
      ...
  }
  ...
}
}}}
        # You could try using the `@PrepareEverythingForTest` annotation (not recommended).
  # Does PowerMock work with TestNG?
      At the moment PowerMock doesn't support TestNG. We hope to able to do so in the future.
  # Is PowerMock a fork of EasyMock?
      No. PowerMock extends other mock frameworks such as EasyMock with powerful capabilities such as static mocking.